<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NYC Eats</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin>
  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">

  <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="sidebar">
  <h1>NYC Eats</h1>
  <p class="subtitle">{{ venue_count | e }} venues ¬∑ {{ build_time | e }}</p>

  <div class="filter-section">
    <h2>Sources</h2>
    <div id="source-filters">
      {% for src in all_sources %}
      <label>
        <input type="checkbox" class="source-cb" value="{{ src | e }}" checked>
        {{ src | e }}
      </label>
      {% endfor %}
    </div>
  </div>

  <div class="filter-section">
    <h2>Tags</h2>
    <div id="tag-filters">
      {% for tag in all_tags %}
      <label>
        <input type="checkbox" class="tag-cb" value="{{ tag | e }}" checked>
        {{ tag | e }}
      </label>
      {% endfor %}
    </div>
  </div>

  <div class="filter-section">
    <h2>Search</h2>
    <input type="text" id="search-input" placeholder="Name, cuisine, address‚Ä¶">
  </div>

  <div class="filter-section">
    <button id="apply-btn">Apply Filters</button>
    <button id="reset-btn">Reset</button>
    <p id="visible-count"></p>
  </div>

  <div class="filter-section sources-info">
    <h2>Data Sources</h2>
    <ul>
      {% for src in sources %}
      <li><strong>{{ src.name | e }}</strong>: {{ src.description | e }} ({{ "{:,}".format(src.count) }} venues)</li>
      {% endfor %}
    </ul>

    <h3>Pipeline</h3>
    <table class="pipeline-table">
      <thead><tr><th>Step</th><th>Result</th></tr></thead>
      <tbody>
        <tr><td>Raw input</td><td>{{ "{:,}".format(merge_stats.pre_merge) }} venues</td></tr>
        {% for s in pipeline_stats %}
        <tr><td>{{ s.label | e }}</td><td>&minus;{{ "{:,}".format(s.removed) }} ({{ s.detail | e }})</td></tr>
        {% endfor %}
        <tr><td>Pass 1 &mdash; exact address + borough</td><td>{{ "{:,}".format(merge_stats.pass1) }} merges</td></tr>
        <tr><td>Pass 2 &mdash; address range containment</td><td>{{ "{:,}".format(merge_stats.pass2) }} merges</td></tr>
        <tr><td>Pass 3 &mdash; geo-proximity &le; 30 m</td><td>{{ "{:,}".format(merge_stats.pass3) }} merges</td></tr>
        <tr class="pipeline-total"><td>Final</td><td>{{ "{:,}".format(merge_stats.post_merge) }} venues ({{ "{:,}".format(merge_stats.total_merges) }} merged)</td></tr>
      </tbody>
    </table>

    <h3>Discovery Badges</h3>
    <ul class="xr-legend">
      <li><span class="xr-badge-icon" style="color:#2563eb">G</span> Google hidden gem (&lt;100 reviews, &gt;4‚òÖ)</li>
      <li><span class="xr-badge-icon" style="color:#dc2626">Y</span> Yelp hidden gem (&lt;100 reviews, &gt;4‚òÖ)</li>
      <li><span class="xr-badge-icon" style="color:#f59e0b">‚è±</span> Opened &lt; 1 month ago</li>
      <li><span class="xr-badge-icon" style="color:#dc2626">‚òÖ</span> Not on Yelp</li>
      <li><span class="xr-badge-icon" style="color:#2563eb">‚òÖ</span> Not on Google Maps</li>
      <li><span class="xr-badge-icon" style="color:#9333ea">‚òÖ</span> Not on either</li>
    </ul>
    <div id="badge-filters" class="badge-filters">
      <button class="badge-filter-btn" data-badge="google-gem"><span style="color:#2563eb">G</span> Google Gems</button>
      <button class="badge-filter-btn" data-badge="yelp-gem"><span style="color:#dc2626">Y</span> Yelp Gems</button>
      <button class="badge-filter-btn" data-badge="new-venue"><span style="color:#f59e0b">‚è±</span> New</button>
      <button class="badge-filter-btn" data-badge="not-on-yelp"><span style="color:#dc2626">‚òÖ</span> No Yelp</button>
      <button class="badge-filter-btn" data-badge="not-on-google"><span style="color:#2563eb">‚òÖ</span> No Google</button>
      <button class="badge-filter-btn" data-badge="any">All flagged</button>
    </div>
    <div id="xr-venue-list" class="xr-venue-list"></div>

    <a href="https://github.com/jareklupinski/nyc-eats" target="_blank" rel="noopener" class="github-link">
      <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.65 7.65 0 0 1 2-.27c.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
      Source
    </a>
  </div>
</div>

<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<!-- Venue data (generated at build time) -->
<script src="venues.js?v={{ data_hash }}"></script>

<script>
(function () {
  "use strict";

  // --- Map setup ---
  const map = L.map("map", {
    center: [40.7128, -74.006],
    zoom: 11,
    preferCanvas: true,          // much faster for many markers
    maxZoom: 19,
  });

  L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
    maxZoom: 19,
  }).addTo(map);

  // --- Marker cluster layer ---
  const clusterGroup = L.markerClusterGroup({
    chunkedLoading: true,        // don't freeze the UI
    chunkInterval: 100,
    chunkDelay: 10,
    maxClusterRadius: 50,
    spiderfyOnMaxZoom: true,
    spiderfyOnEveryZoom: true,
    spiderfyDistanceMultiplier: 1.5,
  });
  map.addLayer(clusterGroup);

  // --- Marker icons by source + grade ---
  const COLORS = {
    dohmh: "#2563eb",   // blue
    both:  "#7c3aed",   // purple
    sla:   "#dc2626",   // red
  };
  const DEFAULT_COLOR = "#6b7280";

  // Icon cache to avoid creating thousands of duplicate DOM icon objects
  const iconCache = {};

  // Build date for "new venue" detection (opened < 1 month ago)
  const NOW = new Date();
  const ONE_MONTH_AGO = new Date(NOW);
  ONE_MONTH_AGO.setMonth(ONE_MONTH_AGO.getMonth() - 1);
  const ONE_MONTH_AGO_STR = ONE_MONTH_AGO.toISOString().slice(0, 10);

  // --- Badge detection ---
  // Returns array of badge objects for a venue (can have multiple)
  function venueBadges(venue) {
    const badges = [];
    // Google hidden gem: found on Google, <100 reviews, >4 stars
    if (venue.xr_g === "found" && venue.gr != null && venue.gr < 100 && venue.grt != null && venue.grt > 4) {
      badges.push({ type: "google-gem", label: "G", color: "#2563eb", cls: "badge-g" });
    }
    // Yelp hidden gem: found on Yelp, <100 reviews, >4 stars
    if (venue.xr_y === "found" && venue.yr != null && venue.yr < 100 && venue.yrt != null && venue.yrt > 4) {
      badges.push({ type: "yelp-gem", label: "Y", color: "#dc2626", cls: "badge-y" });
    }
    // New venue: opened less than 1 month ago
    if (venue.opened && venue.opened >= ONE_MONTH_AGO_STR) {
      badges.push({ type: "new-venue", label: "\u23F1", color: "#f59e0b", cls: "badge-new" });
    }
    // Not on Yelp
    if (venue.xr_y === "not_found") {
      badges.push({ type: "not-on-yelp", label: "\u2605", color: "#dc2626", cls: "xr-red" });
    }
    // Not on Google
    if (venue.xr_g === "not_found") {
      badges.push({ type: "not-on-google", label: "\u2605", color: "#2563eb", cls: "xr-blue" });
    }
    return badges;
  }

  // Legacy compat ‚Äî returns the top-priority badge for the marker icon
  function topBadge(venue) {
    const b = venueBadges(venue);
    return b.length ? b[0] : null;
  }

  function makeIcon(venue) {
    const src = venue.source;
    const grade = (venue.grade || "").trim().toUpperCase();

    let label, color, cls;

    if (src === "sla") {
      label = "\uD83C\uDF78";  // üç∏
      color = COLORS.sla;
      cls = "vm-martini";
    } else if (src === "both") {
      label = (grade && grade !== "P" && grade !== "N" && grade !== "Z") ? grade : "?";
      color = COLORS.both;
      cls = "vm-letter";
    } else {
      label = (grade && grade !== "P" && grade !== "N" && grade !== "Z") ? grade : "?";
      color = COLORS.dohmh;
      cls = "vm-letter";
    }

    const badge = topBadge(venue);
    const badgeHtml = badge ? `<span class="xr-star" style="color:${badge.color}">${badge.label}</span>` : "";
    const badgeKey = badge ? badge.cls : "none";

    const key = `${cls}-${color}-${label}-${badgeKey}`;
    if (!iconCache[key]) {
      iconCache[key] = L.divIcon({
        className: `venue-marker ${cls}${badge ? ' has-star' : ''}`,
        html: `<span style="color:${color}">${label}</span>${badgeHtml}`,
        iconSize: [16, 16],
        iconAnchor: [8, 8],
      });
    }
    return iconCache[key];
  }

  // --- Build markers ---
  const allMarkers = [];

  for (const v of VENUE_DATA) {
    const popupParts = [`<strong>${escHtml(v.name)}</strong>`];
    if (v.sla_name && v.sla_name.toLowerCase() !== v.name.toLowerCase()) {
      popupParts.push(`<em class="popup-aka">SLA: ${escHtml(v.sla_name)}</em>`);
    }
    if (v.cuisine) popupParts.push(escHtml(v.cuisine));
    if (v.address) popupParts.push(escHtml(v.address));
    if (v.borough) popupParts.push(escHtml(v.borough));
    if (v.grade)   popupParts.push(`Grade: ${escHtml(v.grade)}`);
    if (v.phone)   popupParts.push(escHtml(v.phone));
    popupParts.push(`<span class="popup-source">${escHtml(v.source)}</span>`);
    if (v.tags && v.tags.length) {
      popupParts.push(`<span class="popup-tags">${v.tags.map(escHtml).join(", ")}</span>`);
    }
    // Cross-ref badges
    const badges = venueBadges(v);
    if (badges.length) {
      for (const b of badges) {
        if (b.type === "google-gem") {
          popupParts.push(`<span class="xr-badge" style="color:${b.color}">G Google hidden gem (${v.grt}‚òÖ, ${v.gr} reviews)</span>`);
        } else if (b.type === "yelp-gem") {
          popupParts.push(`<span class="xr-badge" style="color:${b.color}">Y Yelp hidden gem (${v.yrt}‚òÖ, ${v.yr} reviews)</span>`);
        } else if (b.type === "new-venue") {
          popupParts.push(`<span class="xr-badge" style="color:${b.color}">‚è± Opened ${v.opened}</span>`);
        } else if (b.type === "not-on-yelp") {
          popupParts.push(`<span class="xr-badge" style="color:${b.color}">‚òÖ Not on Yelp</span>`);
        } else if (b.type === "not-on-google") {
          popupParts.push(`<span class="xr-badge" style="color:${b.color}">‚òÖ Not on Google Maps</span>`);
        }
      }
    }
    // Review counts / ratings
    const reviewParts = [];
    if (v.yr != null) {
      reviewParts.push(`Yelp: ${v.yrt != null ? v.yrt + '‚òÖ' : '?'} (${v.yr} reviews)`);
    }
    if (v.gr != null) {
      reviewParts.push(`Google: ${v.grt != null ? v.grt + '‚òÖ' : '?'} (${v.gr} reviews)`);
    }
    if (reviewParts.length) {
      popupParts.push(`<span class="popup-reviews">${reviewParts.join(' ¬∑ ')}</span>`);
    }

    const marker = L.marker([v.lat, v.lng], { icon: makeIcon(v) });
    marker.bindPopup(popupParts.join("<br>"), { maxWidth: 260 });

    // Attach venue data for filtering
    marker._venue = v;
    allMarkers.push(marker);
  }

  // Initial add
  clusterGroup.addLayers(allMarkers);
  updateCount(allMarkers.length);

  // --- Filtering ---
  const searchInput = document.getElementById("search-input");
  const applyBtn = document.getElementById("apply-btn");
  const resetBtn = document.getElementById("reset-btn");

  applyBtn.addEventListener("click", applyFilters);
  resetBtn.addEventListener("click", resetFilters);
  searchInput.addEventListener("keyup", function (e) {
    if (e.key === "Enter") applyFilters();
  });

  function applyFilters() {
    const activeSources = new Set(
      [...document.querySelectorAll(".source-cb:checked")].map(cb => cb.value)
    );
    const activeTags = new Set(
      [...document.querySelectorAll(".tag-cb:checked")].map(cb => cb.value)
    );
    const query = searchInput.value.trim().toLowerCase();

    clusterGroup.clearLayers();

    const visible = allMarkers.filter(m => {
      const v = m._venue;
      if (!activeSources.has(v.source)) return false;
      if (v.tags && v.tags.length) {
        if (!v.tags.some(t => activeTags.has(t))) return false;
      }
      if (query) {
        const hay = [v.name, v.cuisine, v.address, v.borough, ...(v.tags || [])].join(" ").toLowerCase();
        if (!hay.includes(query)) return false;
      }
      return true;
    });

    clusterGroup.addLayers(visible);
    updateCount(visible.length);
  }

  function resetFilters() {
    document.querySelectorAll(".source-cb, .tag-cb").forEach(cb => cb.checked = true);
    searchInput.value = "";
    clusterGroup.clearLayers();
    clusterGroup.addLayers(allMarkers);
    updateCount(allMarkers.length);
  }

  function updateCount(n) {
    document.getElementById("visible-count").textContent =
      n.toLocaleString() + " venues shown";
  }

  function escHtml(s) {
    const div = document.createElement("div");
    div.textContent = s || "";
    return div.innerHTML;
  }

  // --- Badge filters ---
  const xrList = document.getElementById("xr-venue-list");
  let activeBadgeFilter = null;

  // Precompute badge sets for each filter type
  function markersForBadge(type) {
    return allMarkers.filter(m => {
      const badges = venueBadges(m._venue);
      if (type === "any") return badges.length > 0;
      return badges.some(b => b.type === type);
    });
  }

  // Set up badge filter buttons
  document.querySelectorAll(".badge-filter-btn").forEach(btn => {
    const type = btn.dataset.badge;
    const count = markersForBadge(type).length;
    btn.innerHTML += ` (${count})`;
    if (count === 0) btn.style.opacity = "0.4";

    btn.addEventListener("click", () => {
      const wasActive = btn.classList.contains("active");
      // Deactivate all
      document.querySelectorAll(".badge-filter-btn").forEach(b => b.classList.remove("active"));
      clusterGroup.clearLayers();
      xrList.innerHTML = "";

      if (wasActive) {
        activeBadgeFilter = null;
        clusterGroup.addLayers(allMarkers);
        updateCount(allMarkers.length);
      } else {
        activeBadgeFilter = type;
        btn.classList.add("active");
        const filtered = markersForBadge(type);
        clusterGroup.addLayers(filtered);
        updateCount(filtered.length);
        // Build clickable list
        xrList.innerHTML = filtered.map(m => {
          const v = m._venue;
          const badges = venueBadges(v);
          const top = type === "any" ? badges[0] : badges.find(b => b.type === type) || badges[0];
          let detail = "";
          if (top.type === "google-gem") detail = `${v.grt}‚òÖ ¬∑ ${v.gr} reviews`;
          else if (top.type === "yelp-gem") detail = `${v.yrt}‚òÖ ¬∑ ${v.yr} reviews`;
          else if (top.type === "new-venue") detail = `opened ${v.opened}`;
          return `<a class="xr-venue-item" data-lat="${v.lat}" data-lng="${v.lng}" style="border-left:3px solid ${top.color}">` +
            `<span class="xr-badge-icon" style="color:${top.color}">${top.label}</span> ${escHtml(v.name)}` +
            `<small>${detail || escHtml(v.address || "")}</small></a>`;
        }).join("");
        xrList.querySelectorAll(".xr-venue-item").forEach((el, i) => {
          el.addEventListener("click", () => {
            const lat = parseFloat(el.dataset.lat);
            const lng = parseFloat(el.dataset.lng);
            map.setView([lat, lng], 18);
            filtered[i].openPopup();
          });
        });
      }
    });
  });

  // --- Toggle sidebar on mobile ---
  const sidebar = document.getElementById("sidebar");
  const toggleBtn = document.createElement("button");
  toggleBtn.id = "sidebar-toggle";
  toggleBtn.textContent = "‚ò∞";
  toggleBtn.addEventListener("click", () => sidebar.classList.toggle("open"));
  document.body.appendChild(toggleBtn);
})();
</script>
</body>
</html>
